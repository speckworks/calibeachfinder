{"ast":null,"code":"var localRoutes = [];\n/**\n * Convert path to route object\n *\n * A string or RegExp should be passed,\n * will return { re, src, keys} obj\n *\n * @param  {String / RegExp} path\n * @return {Object}\n */\n\nvar Route = function (path) {\n  //using 'new' is optional\n  var src,\n      re,\n      keys = [];\n\n  if (path instanceof RegExp) {\n    re = path;\n    src = path.toString();\n  } else {\n    re = pathToRegExp(path, keys);\n    src = path;\n  }\n\n  return {\n    re: re,\n    src: path.toString(),\n    keys: keys\n  };\n};\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String} path\n * @param  {Array} keys\n * @return {RegExp}\n */\n\n\nvar pathToRegExp = function (path, keys) {\n  path = path.concat('/?').replace(/\\/\\(/g, '(?:/').replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function (_, slash, format, key, capture, optional) {\n    keys.push(key);\n    slash = slash || '';\n    return '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (format || '') + (capture || '([^/]+?)') + ')' + (optional || '');\n  }).replace(/([\\/.])/g, '\\\\$1').replace(/\\*/g, '(.+)');\n  return new RegExp('^' + path + '$', 'i');\n};\n/**\n * Attempt to match the given request to\n * one of the routes. When successful\n * a  {fn, params, splats} obj is returned\n *\n * @param  {Array} routes\n * @param  {String} uri\n * @return {Object}\n */\n\n\nvar match = function (routes, uri) {\n  var captures,\n      i = 0;\n\n  for (var len = routes.length; i < len; ++i) {\n    var route = routes[i],\n        re = route.re,\n        keys = route.keys,\n        splats = [],\n        params = {};\n\n    if (captures = re.exec(uri)) {\n      for (var j = 1, len = captures.length; j < len; ++j) {\n        var key = keys[j - 1],\n            val = typeof captures[j] === 'string' ? decodeURIComponent(captures[j]) : captures[j];\n\n        if (key) {\n          params[key] = val;\n        } else {\n          splats.push(val);\n        }\n      }\n\n      return {\n        params: params,\n        splats: splats,\n        route: route.src\n      };\n    }\n  }\n};\n/**\n * Default \"normal\" router constructor.\n * accepts path, fn tuples via addRoute\n * returns {fn, params, splats, route}\n *  via match\n *\n * @return {Object}\n */\n\n\nvar Router = function () {\n  //using 'new' is optional\n  return {\n    routes: [],\n    routeMap: {},\n    addRoute: function (path, fn) {\n      if (!path) throw new Error(' route requires a path');\n      if (!fn) throw new Error(' route ' + path.toString() + ' requires a callback');\n      var route = Route(path);\n      route.fn = fn;\n      this.routes.push(route);\n      this.routeMap[path] = fn;\n    },\n    match: function (pathname) {\n      var route = match(this.routes, pathname);\n\n      if (route) {\n        route.fn = this.routeMap[route.route];\n      }\n\n      return route;\n    }\n  };\n};\n\nRouter.Route = Route;\nRouter.pathToRegExp = pathToRegExp;\nRouter.match = match; // back compat\n\nRouter.Router = Router;\nmodule.exports = Router;","map":{"version":3,"sources":["/Users/johnspeck/Flatiron - Labs - etc./Mod_5/californiabeachfinder/frontend/node_modules/routes/index.js"],"names":["localRoutes","Route","path","src","re","keys","RegExp","toString","pathToRegExp","concat","replace","_","slash","format","key","capture","optional","push","match","routes","uri","captures","i","len","length","route","splats","params","exec","j","val","decodeURIComponent","Router","routeMap","addRoute","fn","Error","pathname","module","exports"],"mappings":"AACA,IAAIA,WAAW,GAAG,EAAlB;AAGA;;;;;;;;;;AAUA,IAAIC,KAAK,GAAG,UAASC,IAAT,EAAc;AACxB;AAEA,MAAIC,GAAJ;AAAA,MAASC,EAAT;AAAA,MAAaC,IAAI,GAAG,EAApB;;AAEA,MAAGH,IAAI,YAAYI,MAAnB,EAA0B;AACxBF,IAAAA,EAAE,GAAGF,IAAL;AACAC,IAAAA,GAAG,GAAGD,IAAI,CAACK,QAAL,EAAN;AACD,GAHD,MAGK;AACHH,IAAAA,EAAE,GAAGI,YAAY,CAACN,IAAD,EAAOG,IAAP,CAAjB;AACAF,IAAAA,GAAG,GAAGD,IAAN;AACD;;AAED,SAAO;AACLE,IAAAA,EAAE,EAAEA,EADC;AAELD,IAAAA,GAAG,EAAED,IAAI,CAACK,QAAL,EAFA;AAGLF,IAAAA,IAAI,EAAEA;AAHD,GAAP;AAKD,CAlBD;AAoBA;;;;;;;;;;;;;;;AAaA,IAAIG,YAAY,GAAG,UAAUN,IAAV,EAAgBG,IAAhB,EAAsB;AACxCH,EAAAA,IAAI,GAAGA,IAAI,CACTO,MADK,CACE,IADF,EAELC,OAFK,CAEG,OAFH,EAEY,MAFZ,EAGLA,OAHK,CAGG,sCAHH,EAG2C,UAASC,CAAT,EAAYC,KAAZ,EAAmBC,MAAnB,EAA2BC,GAA3B,EAAgCC,OAAhC,EAAyCC,QAAzC,EAAkD;AAClGX,IAAAA,IAAI,CAACY,IAAL,CAAUH,GAAV;AACAF,IAAAA,KAAK,GAAGA,KAAK,IAAI,EAAjB;AACA,WAAO,MACHI,QAAQ,GAAG,EAAH,GAAQJ,KADb,IAEJ,KAFI,IAGHI,QAAQ,GAAGJ,KAAH,GAAW,EAHhB,KAIHC,MAAM,IAAI,EAJP,KAIcE,OAAO,IAAI,UAJzB,IAIuC,GAJvC,IAKHC,QAAQ,IAAI,EALT,CAAP;AAMA,GAZK,EAaLN,OAbK,CAaG,UAbH,EAae,MAbf,EAcLA,OAdK,CAcG,KAdH,EAcU,MAdV,CAAP;AAeA,SAAO,IAAIJ,MAAJ,CAAW,MAAMJ,IAAN,GAAa,GAAxB,EAA6B,GAA7B,CAAP;AACA,CAjBD;AAmBA;;;;;;;;;;;AASA,IAAIgB,KAAK,GAAG,UAAUC,MAAV,EAAkBC,GAAlB,EAAuB;AAClC,MAAIC,QAAJ;AAAA,MAAcC,CAAC,GAAG,CAAlB;;AAEA,OAAK,IAAIC,GAAG,GAAGJ,MAAM,CAACK,MAAtB,EAA8BF,CAAC,GAAGC,GAAlC,EAAuC,EAAED,CAAzC,EAA4C;AAC3C,QAAIG,KAAK,GAAGN,MAAM,CAACG,CAAD,CAAlB;AAAA,QACIlB,EAAE,GAAGqB,KAAK,CAACrB,EADf;AAAA,QAEIC,IAAI,GAAGoB,KAAK,CAACpB,IAFjB;AAAA,QAGIqB,MAAM,GAAG,EAHb;AAAA,QAIIC,MAAM,GAAG,EAJb;;AAMA,QAAIN,QAAQ,GAAGjB,EAAE,CAACwB,IAAH,CAAQR,GAAR,CAAf,EAA6B;AAC5B,WAAK,IAAIS,CAAC,GAAG,CAAR,EAAWN,GAAG,GAAGF,QAAQ,CAACG,MAA/B,EAAuCK,CAAC,GAAGN,GAA3C,EAAgD,EAAEM,CAAlD,EAAqD;AACpD,YAAIf,GAAG,GAAGT,IAAI,CAACwB,CAAC,GAAC,CAAH,CAAd;AAAA,YACCC,GAAG,GAAG,OAAOT,QAAQ,CAACQ,CAAD,CAAf,KAAuB,QAAvB,GACHE,kBAAkB,CAACV,QAAQ,CAACQ,CAAD,CAAT,CADf,GAEHR,QAAQ,CAACQ,CAAD,CAHZ;;AAIA,YAAIf,GAAJ,EAAS;AACRa,UAAAA,MAAM,CAACb,GAAD,CAAN,GAAcgB,GAAd;AACA,SAFD,MAEO;AACNJ,UAAAA,MAAM,CAACT,IAAP,CAAYa,GAAZ;AACA;AACD;;AACD,aAAO;AACNH,QAAAA,MAAM,EAAEA,MADF;AAEND,QAAAA,MAAM,EAAEA,MAFF;AAGND,QAAAA,KAAK,EAAEA,KAAK,CAACtB;AAHP,OAAP;AAKA;AACD;AACD,CA7BD;AA+BA;;;;;;;;;;AASA,IAAI6B,MAAM,GAAG,YAAU;AACrB;AACA,SAAO;AACLb,IAAAA,MAAM,EAAE,EADH;AAELc,IAAAA,QAAQ,EAAG,EAFN;AAGLC,IAAAA,QAAQ,EAAE,UAAShC,IAAT,EAAeiC,EAAf,EAAkB;AAC1B,UAAI,CAACjC,IAAL,EAAW,MAAM,IAAIkC,KAAJ,CAAU,wBAAV,CAAN;AACX,UAAI,CAACD,EAAL,EAAS,MAAM,IAAIC,KAAJ,CAAU,YAAYlC,IAAI,CAACK,QAAL,EAAZ,GAA8B,sBAAxC,CAAN;AAET,UAAIkB,KAAK,GAAGxB,KAAK,CAACC,IAAD,CAAjB;AACAuB,MAAAA,KAAK,CAACU,EAAN,GAAWA,EAAX;AAEA,WAAKhB,MAAL,CAAYF,IAAZ,CAAiBQ,KAAjB;AACA,WAAKQ,QAAL,CAAc/B,IAAd,IAAsBiC,EAAtB;AACD,KAZI;AAcLjB,IAAAA,KAAK,EAAE,UAASmB,QAAT,EAAkB;AACvB,UAAIZ,KAAK,GAAGP,KAAK,CAAC,KAAKC,MAAN,EAAckB,QAAd,CAAjB;;AACA,UAAGZ,KAAH,EAAS;AACPA,QAAAA,KAAK,CAACU,EAAN,GAAW,KAAKF,QAAL,CAAcR,KAAK,CAACA,KAApB,CAAX;AACD;;AACD,aAAOA,KAAP;AACD;AApBI,GAAP;AAsBD,CAxBD;;AA0BAO,MAAM,CAAC/B,KAAP,GAAeA,KAAf;AACA+B,MAAM,CAACxB,YAAP,GAAsBA,YAAtB;AACAwB,MAAM,CAACd,KAAP,GAAeA,KAAf,C,CACA;;AACAc,MAAM,CAACA,MAAP,GAAgBA,MAAhB;AAEAM,MAAM,CAACC,OAAP,GAAiBP,MAAjB","sourcesContent":["\nvar localRoutes = [];\n\n\n/**\n * Convert path to route object\n *\n * A string or RegExp should be passed,\n * will return { re, src, keys} obj\n *\n * @param  {String / RegExp} path\n * @return {Object}\n */\n \nvar Route = function(path){\n  //using 'new' is optional\n  \n  var src, re, keys = [];\n  \n  if(path instanceof RegExp){\n    re = path;\n    src = path.toString();\n  }else{\n    re = pathToRegExp(path, keys);\n    src = path;\n  }\n\n  return {\n  \t re: re,\n  \t src: path.toString(),\n  \t keys: keys\n  }\n};\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String} path\n * @param  {Array} keys\n * @return {RegExp}\n */\nvar pathToRegExp = function (path, keys) {\n\tpath = path\n\t\t.concat('/?')\n\t\t.replace(/\\/\\(/g, '(?:/')\n\t\t.replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?/g, function(_, slash, format, key, capture, optional){\n\t\t\tkeys.push(key);\n\t\t\tslash = slash || '';\n\t\t\treturn ''\n\t\t\t\t+ (optional ? '' : slash)\n\t\t\t\t+ '(?:'\n\t\t\t\t+ (optional ? slash : '')\n\t\t\t\t+ (format || '') + (capture || '([^/]+?)') + ')'\n\t\t\t\t+ (optional || '');\n\t\t})\n\t\t.replace(/([\\/.])/g, '\\\\$1')\n\t\t.replace(/\\*/g, '(.+)');\n\treturn new RegExp('^' + path + '$', 'i');\n};\n\n/**\n * Attempt to match the given request to\n * one of the routes. When successful\n * a  {fn, params, splats} obj is returned\n *\n * @param  {Array} routes\n * @param  {String} uri\n * @return {Object}\n */\nvar match = function (routes, uri) {\n\tvar captures, i = 0;\n\n\tfor (var len = routes.length; i < len; ++i) {\n\t\tvar route = routes[i],\n\t\t    re = route.re,\n\t\t    keys = route.keys,\n\t\t    splats = [],\n\t\t    params = {};\n\n\t\tif (captures = re.exec(uri)) {\n\t\t\tfor (var j = 1, len = captures.length; j < len; ++j) {\n\t\t\t\tvar key = keys[j-1],\n\t\t\t\t\tval = typeof captures[j] === 'string'\n\t\t\t\t\t\t? decodeURIComponent(captures[j])\n\t\t\t\t\t\t: captures[j];\n\t\t\t\tif (key) {\n\t\t\t\t\tparams[key] = val;\n\t\t\t\t} else {\n\t\t\t\t\tsplats.push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tparams: params,\n\t\t\t\tsplats: splats,\n\t\t\t\troute: route.src\n\t\t\t};\n\t\t}\n\t}\n};\n\n/**\n * Default \"normal\" router constructor.\n * accepts path, fn tuples via addRoute\n * returns {fn, params, splats, route}\n *  via match\n *\n * @return {Object}\n */\n \nvar Router = function(){\n  //using 'new' is optional\n  return {\n    routes: [],\n    routeMap : {},\n    addRoute: function(path, fn){\n      if (!path) throw new Error(' route requires a path');\n      if (!fn) throw new Error(' route ' + path.toString() + ' requires a callback');\n\n      var route = Route(path);\n      route.fn = fn;\n\n      this.routes.push(route);\n      this.routeMap[path] = fn;\n    },\n\n    match: function(pathname){\n      var route = match(this.routes, pathname);\n      if(route){\n        route.fn = this.routeMap[route.route];\n      }\n      return route;\n    }\n  }\n};\n\nRouter.Route = Route\nRouter.pathToRegExp = pathToRegExp\nRouter.match = match\n// back compat\nRouter.Router = Router\n\nmodule.exports = Router\n"]},"metadata":{},"sourceType":"script"}